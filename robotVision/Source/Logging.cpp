#include "Logging.h"

// Get information on a given error identifier. This is
//intended to be used for C functions that identify an
//error through a setting of errno and a specific return.
std::string Logging::getFormattedErrnoInfo(int errnoToCheck)
{
    std::stringstream result;
    result << "ERRNO: " << errnoToCheck << " (" << std::strerror(errnoToCheck) << ").";

    return result.str();
}

// Same as getFormattedErrnoInfo except uses the global
//errno variable.
std::string Logging::getFormattedErrnoInfo()
{
    return Logging::getFormattedErrnoInfo(errno);
}

// Allows the output of colors to the Linux terminal.
// See the console_codes Linux man page.
std::string Logging::getSetStyleCode(const Logging::TerminalStyle& style)
{
    std::string result;

    switch(style)
    {
        case Logging::TerminalStyle::NORMAL:
            result = "\033[0m";
        break;
        case Logging::TerminalStyle::BOLD:
            result = "\033[1m";
        break;
        case Logging::TerminalStyle::UNDERLINE:
            result = "\033[4m";
        break;
        case Logging::TerminalStyle::END_BOLD:
            result = "\033[22m";
        break;
        case Logging::TerminalStyle::END_UNDERLINE:
            result = "\033[24m";
        break;
        case Logging::TerminalStyle::FG_RED:
            result = "\033[31m";
        break;
        case Logging::TerminalStyle::FG_GREEN:
            result = "\033[32m";
        break;
        case Logging::TerminalStyle::FG_YELLOW:
            result = "\033[33m";
        break;
    }

    return result;
}

// Output an error and its description to standard error. Later this might save error information or
//send it to a driver station over a network connection.
void Logging::ErrorLogger::log(const std::string& location, const std::string& description, const std::string& potentialIssues)
{
    std::stringstream stringBuilder;
    stringBuilder << Logging::getSetStyleCode(Logging::TerminalStyle::FG_RED);

    stringBuilder << Logging::getSetStyleCode(Logging::TerminalStyle::BOLD);
    stringBuilder << "Error: ";
    stringBuilder << Logging::getSetStyleCode(Logging::TerminalStyle::END_BOLD);

    stringBuilder << location << std::endl;
    stringBuilder << "I: " << description << std::endl;
    stringBuilder << "Potential Issues: " << potentialIssues << std::endl;
    stringBuilder << Logging::getFormattedErrnoInfo();
    stringBuilder << Logging::getSetStyleCode(Logging::TerminalStyle::NORMAL);

    if(multiLine)
    {
        stringBuilder << std::endl;
    }

    // Print the newly-built string to the console.
    //Note that this string was created with a separate
    //stream to facilitate doing other things with the error
    //message, such as saving it to a file, or sending it
    //over the network.
    std::cerr << stringBuilder.str();
}

// This function exists to override Logging::Logger::log,
//allowing opperators defined in Logger to work.
void Logging::ErrorLogger::log(const std::string& message)
{
    std::stringstream stringBuilder;
    stringBuilder << Logging::getSetStyleCode(Logging::TerminalStyle::FG_RED);

    // If this function is being called through a call to error << ...,
    //do not prepend an error label. This prevents output such as:
    //Error: Unable to open portError: 2000Error: please check port availability.
    if(!isInStream)
    {
        stringBuilder << Logging::getSetStyleCode(Logging::TerminalStyle::BOLD);

        stringBuilder << "Error: ";

        stringBuilder << Logging::getSetStyleCode(Logging::TerminalStyle::END_BOLD);
    }

    stringBuilder << message;

    // To avoid repeated errno information, this is only given when
    //error information is not outputed through error << ...
    if(!isInStream)
    {
        stringBuilder << " " << Logging::getFormattedErrnoInfo();
    }

    stringBuilder << Logging::getSetStyleCode(Logging::TerminalStyle::NORMAL);

    if(multiLine)
    {
        stringBuilder << std::endl;
    }

    std::cerr << stringBuilder.str();
}

// Overload of the error-logger's operator() for compatability.
void Logging::ErrorLogger::operator()(const std::string& location, const std::string& description, const std::string& potentialIssues)
{
    log(location, description, potentialIssues);
}

// Output a warning to standard output.
void Logging::WarningLogger::log(const std::string& message)
{
    std::stringstream stringBuilder;
    stringBuilder << Logging::getSetStyleCode(TerminalStyle::FG_YELLOW);

    // Only add warning label if not generated by warn << warningText.
    if(!isInStream)
    {
        stringBuilder << Logging::getSetStyleCode(Logging::TerminalStyle::BOLD);

        stringBuilder << "Warning: ";

        stringBuilder << Logging::getSetStyleCode(Logging::TerminalStyle::END_BOLD);
    }

    stringBuilder << message;

    // For every chunk outputed through the << operator, 
    //errno information would be added to the string builder.
    //This is probably not desired output, so is not done for
    //streams.
    if(!isInStream)
    {
        stringBuilder << " " << Logging::getFormattedErrnoInfo();
    }

    stringBuilder << Logging::getSetStyleCode(TerminalStyle::NORMAL);

    if(multiLine)
    {
        stringBuilder << std::endl;
    }

    std::cout << stringBuilder.str();
}

// Log a message to standard output.
void Logging::NoticeLogger::log(const std::string& message)
{
    std::stringstream logBuilder;
    logBuilder << message;
    
    if(multiLine)
    {
        logBuilder << std::endl;
    }

    std::cout << logBuilder.str();
}

namespace Logging
{
    ErrorLogger error {};
    WarningLogger warn {};
    NoticeLogger log {};
    std::string endl = "\n"; // DO NOT use std::endl for stream templates. Use Logging::endl.
}