#include<iostream>
#include<opencv2/opencv.hpp>
#include<opencv2/imgproc.hpp>

//
int main()
{
	cv::Mat image=cv::Mat::zeros(4, 4, CV_8UC1);

	std::cout << image << "\n";

	// Open a camera.
	cv::VideoCapture video;
	video.open(0);

	// Open a window.
	cv::namedWindow("Camera View", cv::WINDOW_AUTOSIZE);

	// Create a variable to store the current frame.
	cv::Mat currentFrame, lastFrame;

	// Create a variable to store the last key.
	char lastKey='\0';

	video >> lastFrame;
	//currentFrame.copyTo(lastFrame);

	std::vector<cv::Point2f> corners;

	std::vector<std::vector<cv::Point3f>> cornerPoints;

	std::vector<std::vector<

	// Calibrate the camera.

	do
	{
		video >> currentFrame;
		//currentFrame=currentFrame.colRange(0,
		//	currentFrame.size().height);
		/*cv::Mat erodeDilateElement=cv::getStructuringElement(cv::MORPH_RECT, 
			cv::Size(20, 1));
		cv::erode(currentFrame, currentFrame, erodeDilateElement,
			cv::Point(-1, -1), 3);
		cv::dilate(currentFrame, currentFrame, erodeDilateElement,
			cv::Point(-1, -1),  3);*/
/*
		int x, y;
		unsigned char * ptr;
		for(y=0; y<currentFrame.rows;y++)
		{
			ptr=currentFrame.ptr<unsigned char>(y);
			for(x=0; x<currentFrame.size().width; x++)
			{
				ptr[x*3]*=y;
			}
		}*/
		cv::Size cornerSize=cv::Size(9, 6);
		cv::cvtColor(currentFrame, lastFrame, CV_RGB2GRAY);
		bool success=cv::findChessboardCorners(lastFrame, cornerSize, corners, cv::CALIB_CB_FAST_CHECK + cv::CALIB_CB_ADAPTIVE_THRESH + cv::CALIB_CB_NORMALIZE_IMAGE);

		if(success)
		{
			//std::cout << "Found!";
			cv::cornerSubPix(lastFrame, corners, cv::Size(10, 10), cv::Size(-1, -1), cv::TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 30, 0.1));
			cv::drawChessboardCorners(currentFrame, cornerSize, cv::Mat(corners), success);
			
		}
		cv::undistort(currentFrame, currentFrame, cameraMatrix, distanceCoefficents);
		cv::imshow("Camera View", currentFrame);
		lastKey = cv::waitKey(1);
		currentFrame.copyTo(lastFrame);
	}
	while(lastKey != 'q');

	return 0;
}
